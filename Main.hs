
import Parser
import Tokens
import Control.Monad
import Data.Char

-- Type of all of the Relations and their corrosponding Tables 
type Tables = [(Relation, Table)]

-- Representation of all the information for a single Relational Symbol
data Table = Column String [String] | Columns String [String] Table deriving Show


-- ================================================================  EVAL  ============================================================================================
-- eval :: Program -> Table -> String
-- eval (Program (FromGetExpr fromGet vars)) table = evalFromGetExpr fromGet vars table
-- eval (Program (FromGetWhere fromGet equals vars)) _ = ""

-- =============================================================  TABLE MAKERS  =======================================================================================
-- Get FILEPATHS , returns FILEPATHS 
getFilePaths :: Program -> [FilePath]
getFilePaths (Program (FromGetExpr fromGet _)) = getFilePaths' fromGet
getFilePaths (Program (FromGetWhere fromGet _ _)) = getFilePaths' fromGet

getFilePaths' :: FromGet -> [FilePath]
getFilePaths' (FromGetAnd relation _ fromGet) = getFilePaths'' relation ++ getFilePaths' fromGet
getFilePaths' (FromGet relation _) = getFilePaths'' relation

getFilePaths'' :: Relation -> [FilePath]
getFilePaths'' (Relation r) = [filepath r]


-- Get Relations Variables!, Each variable is assigned to a column in the table! 
getVars :: Program -> [(Relation,[String])]
getVars (Program (FromGetExpr fromGet _)) = getVars' fromGet
getVars (Program (FromGetWhere fromGet _ _)) = getVars' fromGet

getVars' :: FromGet -> [(Relation,[String])] 
getVars' (FromGetAnd relation toGet fromGet) = [(relation, (listVarsToGet toGet))] ++ getVars' fromGet
getVars' (FromGet relation toGet) = [(relation, (listVarsToGet toGet))]

listVarsToGet :: ToGet -> [String]
listVarsToGet (Params1(Var v)) = [v]
listVarsToGet (Params2 toGet toGet1) = listVarsToGet toGet ++ listVarsToGet toGet1


-- Generate the Tables. 
-- Parameter $1: List of each Relation data in order e.g ["hi,bye", "low,high"]
-- Parameter $2: Output of GetVars, the Relation, in order, with the String assignments
makeTables :: [String] -> [(Relation,[String])] -> Tables 
makeTables _ _ = []


-- ================================================================  AUX  =============================================================================================

-- Turns the Data Type:  Vars ====> [String] ; Retains order
varsToString :: Vars -> [String]
varsToString (Vars1 (Var s)) = [s]
varsToString (Vars2 (Var s) vars) = [s] ++ (varsToString vars)


-- Takes a list of CSV e.g : ["Bob", "Alice", "John\n"]  ====> ["Bob", "Alice", "John"]
clean :: [String] -> [String]
clean (x:[]) = wordsWhen (=='\n') x
clean (x:xs) = wordsWhen (=='\n') x ++ clean xs

-- Acts like a SplitOn Function  , wordsWhen (==',') "This,Is,A,CSV" =====> ["This", "Is", "A" , "CSV"]
wordsWhen :: (Char -> Bool) -> String -> [String]
wordsWhen p s =  case dropWhile p s of
                      "" -> []
                      s' -> w : wordsWhen p s''
                            where (w, s'') = break p s'


-- ================================================================  IO  =============================================================================================

readFiles :: [FilePath] -> IO [String]
readFiles ss = mapM readFile ss 

filepath :: String -> FilePath
filepath s = (s ++ ".csv")

-- ================================================================  MAIN  =========================================================================================== 
main :: IO ()
main = do
    s <- getContents

    -- Assigns : ast, to the abstract syntax tree generated by lexer and parser
    let ast = caca (alexScanTokens s)

    -- Assigns : relationContents, to a list containing all of the files info, e.g. file A contains : "hi,bye" and file B contanis "low,high"
    -- then relationContents will be = ["hi,bye", "low,high"]
    -- TODO: make getFilePaths         ; Will navigate the ast to find any and all declarations of: from A, from B and produce [FilePath]: ["A.csv", "B.csv"]
    relationContents <- readFiles (getFilePaths ast)
    print (getVars ast)

    -- Assigns : tables, to be the table containing all info needed to parse correctly. e.g if the files above are name with variable names
    --  A(x1,x2) and B(x3,x4) then Tables will be the following
    -- [(Relation "A", Columns x1 ["hi"] (Column x2 ["bye"])), (Relation "B", Columns x3 ["low"] (Column x4 ["high"]))]
    -- TODO: make makeTables.          ; Should generate of type Tables. 
    -- TODO: re-make getVars.          ; Must include to which Relation each variable is related to, so maybe [(Relation "A", ["x1","x2"]), (Relation "B", ["x3","x4"])]
 --   let tables = makeTables relationContents (getVars ast)


    -- Prints : the full evaluation, eval ast tables for any given program defined by our BNF should produce the desired result with proper error handling.
    -- TODO: FromGetWhere and FromGet. ; Basics, get this working.
    -- TODO: FromGet and FromGetAnd.   ; Basics, get this working.
    -- TODO: AsVars and Equals.        ; Basics, get this working. AsVars is probably where the final printing occurs. (Maybe even all printing?)
    -- TODO: ToGet and Vars.           ; Simple. 
    -- TODO: Some                      ; This is probably going to be very Hard! And will probably make it very hard
--    print (eval ast tables)

